/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef accord_TYPES_H
#define accord_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>



namespace rafdb {

struct State {
  enum type {
    FOLLOWER = 0,
    CANDIDATE = 1,
    LEADER = 2
  };
};

struct MessageType {
  enum type {
    UNKNOWN = 0,
    VOTEREQ = 1,
    VOTEREP = 2,
    HEARTREQ = 3,
    HEARTREP = 4,
    LEADERREQ = 5,
    LEADERREP = 6,
    TIMER = 7
  };
};

typedef struct _Message__isset {
  _Message__isset() : term_id(false), candidate_id(false), server_id(false), leader_id(false), ip(false), port(false), self_healthy(false), granted(false), message_type(false), success(false) {}
  bool term_id;
  bool candidate_id;
  bool server_id;
  bool leader_id;
  bool ip;
  bool port;
  bool self_healthy;
  bool granted;
  bool message_type;
  bool success;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "74FC576BE6E579EAF992564A56E6242B";
  static const uint8_t binary_fingerprint[16]; // = {0x74,0xFC,0x57,0x6B,0xE6,0xE5,0x79,0xEA,0xF9,0x92,0x56,0x4A,0x56,0xE6,0x24,0x2B};

  Message() : term_id(0), candidate_id(0), server_id(0), leader_id(0), ip(""), port(0), self_healthy(0), granted(0), success(0) {
    message_type = (MessageType::type)0;

  }

  virtual ~Message() throw() {}

  int64_t term_id;
  int32_t candidate_id;
  int32_t server_id;
  int32_t leader_id;
  std::string ip;
  int32_t port;
  bool self_healthy;
  bool granted;
  MessageType::type message_type;
  bool success;

  _Message__isset __isset;

  bool operator == (const Message & rhs) const
  {
    if (!(term_id == rhs.term_id))
      return false;
    if (!(candidate_id == rhs.candidate_id))
      return false;
    if (!(server_id == rhs.server_id))
      return false;
    if (!(leader_id == rhs.leader_id))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(self_healthy == rhs.self_healthy))
      return false;
    if (!(granted == rhs.granted))
      return false;
    if (!(message_type == rhs.message_type))
      return false;
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

} // namespace

#endif
